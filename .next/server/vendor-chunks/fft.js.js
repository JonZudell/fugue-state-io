"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fft.js";
exports.ids = ["vendor-chunks/fft.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/fft.js/lib/fft.js":
/*!****************************************!*\
  !*** ./node_modules/fft.js/lib/fft.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n\nfunction FFT(size) {\n  this.size = size | 0;\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n    throw new Error('FFT size must be a power of two and bigger than 1');\n\n  this._csize = size << 1;\n\n  // NOTE: Use of `var` is intentional for old V8 versions\n  var table = new Array(this.size * 2);\n  for (var i = 0; i < table.length; i += 2) {\n    const angle = Math.PI * i / this.size;\n    table[i] = Math.cos(angle);\n    table[i + 1] = -Math.sin(angle);\n  }\n  this.table = table;\n\n  // Find size's power of two\n  var power = 0;\n  for (var t = 1; this.size > t; t <<= 1)\n    power++;\n\n  // Calculate initial step's width:\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n  //   * Otherwise it is the same as `power` to give len=4\n  this._width = power % 2 === 0 ? power - 1 : power;\n\n  // Pre-compute bit-reversal patterns\n  this._bitrev = new Array(1 << this._width);\n  for (var j = 0; j < this._bitrev.length; j++) {\n    this._bitrev[j] = 0;\n    for (var shift = 0; shift < this._width; shift += 2) {\n      var revShift = this._width - shift - 2;\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n    }\n  }\n\n  this._out = null;\n  this._data = null;\n  this._inv = 0;\n}\nmodule.exports = FFT;\n\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n  var res = storage || new Array(complex.length >>> 1);\n  for (var i = 0; i < complex.length; i += 2)\n    res[i >>> 1] = complex[i];\n  return res;\n};\n\nFFT.prototype.createComplexArray = function createComplexArray() {\n  const res = new Array(this._csize);\n  for (var i = 0; i < res.length; i++)\n    res[i] = 0;\n  return res;\n};\n\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n  var res = storage || this.createComplexArray();\n  for (var i = 0; i < res.length; i += 2) {\n    res[i] = input[i >>> 1];\n    res[i + 1] = 0;\n  }\n  return res;\n};\n\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n  var size = this._csize;\n  var half = size >>> 1;\n  for (var i = 2; i < half; i += 2) {\n    spectrum[size - i] = spectrum[i];\n    spectrum[size - i + 1] = -spectrum[i + 1];\n  }\n};\n\nFFT.prototype.transform = function transform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._transform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.realTransform = function realTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._realTransform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 1;\n  this._transform4();\n  for (var i = 0; i < out.length; i++)\n    out[i] /= this.size;\n  this._out = null;\n  this._data = null;\n};\n\n// radix-4 implementation\n//\n// NOTE: Uses of `var` are intentional for older V8 version that do not\n// support both `let compound assignments` and `const phi`\nFFT.prototype._transform4 = function _transform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform2(outOff, off, step);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform4(outOff, off, step);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var quarterLen = len >>> 2;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      // Full case\n      var limit = outOff + quarterLen;\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\n        const A = i;\n        const B = A + quarterLen;\n        const C = B + quarterLen;\n        const D = C + quarterLen;\n\n        // Original values\n        const Ar = out[A];\n        const Ai = out[A + 1];\n        const Br = out[B];\n        const Bi = out[B + 1];\n        const Cr = out[C];\n        const Ci = out[C + 1];\n        const Dr = out[D];\n        const Di = out[D + 1];\n\n        // Middle values\n        const MAr = Ar;\n        const MAi = Ai;\n\n        const tableBr = table[k];\n        const tableBi = inv * table[k + 1];\n        const MBr = Br * tableBr - Bi * tableBi;\n        const MBi = Br * tableBi + Bi * tableBr;\n\n        const tableCr = table[2 * k];\n        const tableCi = inv * table[2 * k + 1];\n        const MCr = Cr * tableCr - Ci * tableCi;\n        const MCi = Cr * tableCi + Ci * tableCr;\n\n        const tableDr = table[3 * k];\n        const tableDi = inv * table[3 * k + 1];\n        const MDr = Dr * tableDr - Di * tableDi;\n        const MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        const T0r = MAr + MCr;\n        const T0i = MAi + MCi;\n        const T1r = MAr - MCr;\n        const T1i = MAi - MCi;\n        const T2r = MBr + MDr;\n        const T2i = MBi + MDi;\n        const T3r = inv * (MBr - MDr);\n        const T3i = inv * (MBi - MDi);\n\n        // Final values\n        const FAr = T0r + T2r;\n        const FAi = T0i + T2i;\n\n        const FCr = T0r - T2r;\n        const FCi = T0i - T2i;\n\n        const FBr = T1r + T3i;\n        const FBi = T1i - T3r;\n\n        const FDr = T1r - T3i;\n        const FDi = T1i + T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n        out[C] = FCr;\n        out[C + 1] = FCi;\n        out[D] = FDr;\n        out[D + 1] = FDi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const evenI = data[off + 1];\n  const oddR = data[off + step];\n  const oddI = data[off + step + 1];\n\n  const leftR = evenR + oddR;\n  const leftI = evenI + oddI;\n  const rightR = evenR - oddR;\n  const rightI = evenI - oddI;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = leftI;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = rightI;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Ai = data[off + 1];\n  const Br = data[off + step];\n  const Bi = data[off + step + 1];\n  const Cr = data[off + step2];\n  const Ci = data[off + step2 + 1];\n  const Dr = data[off + step3];\n  const Di = data[off + step3 + 1];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T0i = Ai + Ci;\n  const T1r = Ar - Cr;\n  const T1i = Ai - Ci;\n  const T2r = Br + Dr;\n  const T2i = Bi + Di;\n  const T3r = inv * (Br - Dr);\n  const T3i = inv * (Bi - Di);\n\n  // Final values\n  const FAr = T0r + T2r;\n  const FAi = T0i + T2i;\n\n  const FBr = T1r + T3i;\n  const FBi = T1i - T3r;\n\n  const FCr = T0r - T2r;\n  const FCi = T0i - T2i;\n\n  const FDr = T1r - T3i;\n  const FDi = T1i + T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = FAi;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = FCi;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n// Real input radix-4 implementation\nFFT.prototype._realTransform4 = function _realTransform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var halfLen = len >>> 1;\n    var quarterLen = halfLen >>> 1;\n    var hquarterLen = quarterLen >>> 1;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n        var A = outOff + i;\n        var B = A + quarterLen;\n        var C = B + quarterLen;\n        var D = C + quarterLen;\n\n        // Original values\n        var Ar = out[A];\n        var Ai = out[A + 1];\n        var Br = out[B];\n        var Bi = out[B + 1];\n        var Cr = out[C];\n        var Ci = out[C + 1];\n        var Dr = out[D];\n        var Di = out[D + 1];\n\n        // Middle values\n        var MAr = Ar;\n        var MAi = Ai;\n\n        var tableBr = table[k];\n        var tableBi = inv * table[k + 1];\n        var MBr = Br * tableBr - Bi * tableBi;\n        var MBi = Br * tableBi + Bi * tableBr;\n\n        var tableCr = table[2 * k];\n        var tableCi = inv * table[2 * k + 1];\n        var MCr = Cr * tableCr - Ci * tableCi;\n        var MCi = Cr * tableCi + Ci * tableCr;\n\n        var tableDr = table[3 * k];\n        var tableDi = inv * table[3 * k + 1];\n        var MDr = Dr * tableDr - Di * tableDi;\n        var MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        var T0r = MAr + MCr;\n        var T0i = MAi + MCi;\n        var T1r = MAr - MCr;\n        var T1i = MAi - MCi;\n        var T2r = MBr + MDr;\n        var T2i = MBi + MDi;\n        var T3r = inv * (MBr - MDr);\n        var T3i = inv * (MBi - MDi);\n\n        // Final values\n        var FAr = T0r + T2r;\n        var FAi = T0i + T2i;\n\n        var FBr = T1r + T3i;\n        var FBi = T1i - T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n\n        // Output final middle point\n        if (i === 0) {\n          var FCr = T0r - T2r;\n          var FCi = T0i - T2i;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          continue;\n        }\n\n        // Do not overwrite ourselves\n        if (i === hquarterLen)\n          continue;\n\n        // In the flipped case:\n        // MAi = -MAi\n        // MBr=-MBi, MBi=-MBr\n        // MCr=-MCr\n        // MDr=MDi, MDi=MDr\n        var ST0r = T1r;\n        var ST0i = -T1i;\n        var ST1r = T0r;\n        var ST1i = -T0i;\n        var ST2r = -inv * T3i;\n        var ST2i = -inv * T3r;\n        var ST3r = -inv * T2i;\n        var ST3i = -inv * T2r;\n\n        var SFAr = ST0r + ST2r;\n        var SFAi = ST0i + ST2i;\n\n        var SFBr = ST1r + ST3i;\n        var SFBi = ST1i - ST3r;\n\n        var SA = outOff + quarterLen - i;\n        var SB = outOff + halfLen - i;\n\n        out[SA] = SFAr;\n        out[SA + 1] = SFAi;\n        out[SB] = SFBr;\n        out[SB + 1] = SFBi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const oddR = data[off + step];\n\n  const leftR = evenR + oddR;\n  const rightR = evenR - oddR;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = 0;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Br = data[off + step];\n  const Cr = data[off + step2];\n  const Dr = data[off + step3];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T1r = Ar - Cr;\n  const T2r = Br + Dr;\n  const T3r = inv * (Br - Dr);\n\n  // Final values\n  const FAr = T0r + T2r;\n\n  const FBr = T1r;\n  const FBi = -T3r;\n\n  const FCr = T0r - T2r;\n\n  const FDr = T1r;\n  const FDi = T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = 0;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmZ0LmpzL2xpYi9mZnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEMsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRob256dWRlbGwvV29ya3NwYWNlL2Z1Z3VlLXN0YXRlLWlvL25vZGVfbW9kdWxlcy9mZnQuanMvbGliL2ZmdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEZGVChzaXplKSB7XG4gIHRoaXMuc2l6ZSA9IHNpemUgfCAwO1xuICBpZiAodGhpcy5zaXplIDw9IDEgfHwgKHRoaXMuc2l6ZSAmICh0aGlzLnNpemUgLSAxKSkgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGRlQgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGFuZCBiaWdnZXIgdGhhbiAxJyk7XG5cbiAgdGhpcy5fY3NpemUgPSBzaXplIDw8IDE7XG5cbiAgLy8gTk9URTogVXNlIG9mIGB2YXJgIGlzIGludGVudGlvbmFsIGZvciBvbGQgVjggdmVyc2lvbnNcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KHRoaXMuc2l6ZSAqIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLlBJICogaSAvIHRoaXMuc2l6ZTtcbiAgICB0YWJsZVtpXSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0YWJsZVtpICsgMV0gPSAtTWF0aC5zaW4oYW5nbGUpO1xuICB9XG4gIHRoaXMudGFibGUgPSB0YWJsZTtcblxuICAvLyBGaW5kIHNpemUncyBwb3dlciBvZiB0d29cbiAgdmFyIHBvd2VyID0gMDtcbiAgZm9yICh2YXIgdCA9IDE7IHRoaXMuc2l6ZSA+IHQ7IHQgPDw9IDEpXG4gICAgcG93ZXIrKztcblxuICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBzdGVwJ3Mgd2lkdGg6XG4gIC8vICAgKiBJZiB3ZSBhcmUgZnVsbCByYWRpeC00IC0gaXQgaXMgMnggc21hbGxlciB0byBnaXZlIGluaXRhbCBsZW49OFxuICAvLyAgICogT3RoZXJ3aXNlIGl0IGlzIHRoZSBzYW1lIGFzIGBwb3dlcmAgdG8gZ2l2ZSBsZW49NFxuICB0aGlzLl93aWR0aCA9IHBvd2VyICUgMiA9PT0gMCA/IHBvd2VyIC0gMSA6IHBvd2VyO1xuXG4gIC8vIFByZS1jb21wdXRlIGJpdC1yZXZlcnNhbCBwYXR0ZXJuc1xuICB0aGlzLl9iaXRyZXYgPSBuZXcgQXJyYXkoMSA8PCB0aGlzLl93aWR0aCk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fYml0cmV2Lmxlbmd0aDsgaisrKSB7XG4gICAgdGhpcy5fYml0cmV2W2pdID0gMDtcbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IHNoaWZ0IDwgdGhpcy5fd2lkdGg7IHNoaWZ0ICs9IDIpIHtcbiAgICAgIHZhciByZXZTaGlmdCA9IHRoaXMuX3dpZHRoIC0gc2hpZnQgLSAyO1xuICAgICAgdGhpcy5fYml0cmV2W2pdIHw9ICgoaiA+Pj4gc2hpZnQpICYgMykgPDwgcmV2U2hpZnQ7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fb3V0ID0gbnVsbDtcbiAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIHRoaXMuX2ludiA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEZGVDtcblxuRkZULnByb3RvdHlwZS5mcm9tQ29tcGxleEFycmF5ID0gZnVuY3Rpb24gZnJvbUNvbXBsZXhBcnJheShjb21wbGV4LCBzdG9yYWdlKSB7XG4gIHZhciByZXMgPSBzdG9yYWdlIHx8IG5ldyBBcnJheShjb21wbGV4Lmxlbmd0aCA+Pj4gMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcGxleC5sZW5ndGg7IGkgKz0gMilcbiAgICByZXNbaSA+Pj4gMV0gPSBjb21wbGV4W2ldO1xuICByZXR1cm4gcmVzO1xufTtcblxuRkZULnByb3RvdHlwZS5jcmVhdGVDb21wbGV4QXJyYXkgPSBmdW5jdGlvbiBjcmVhdGVDb21wbGV4QXJyYXkoKSB7XG4gIGNvbnN0IHJlcyA9IG5ldyBBcnJheSh0aGlzLl9jc2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG4gIHJldHVybiByZXM7XG59O1xuXG5GRlQucHJvdG90eXBlLnRvQ29tcGxleEFycmF5ID0gZnVuY3Rpb24gdG9Db21wbGV4QXJyYXkoaW5wdXQsIHN0b3JhZ2UpIHtcbiAgdmFyIHJlcyA9IHN0b3JhZ2UgfHwgdGhpcy5jcmVhdGVDb21wbGV4QXJyYXkoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXNbaV0gPSBpbnB1dFtpID4+PiAxXTtcbiAgICByZXNbaSArIDFdID0gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuRkZULnByb3RvdHlwZS5jb21wbGV0ZVNwZWN0cnVtID0gZnVuY3Rpb24gY29tcGxldGVTcGVjdHJ1bShzcGVjdHJ1bSkge1xuICB2YXIgc2l6ZSA9IHRoaXMuX2NzaXplO1xuICB2YXIgaGFsZiA9IHNpemUgPj4+IDE7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgaGFsZjsgaSArPSAyKSB7XG4gICAgc3BlY3RydW1bc2l6ZSAtIGldID0gc3BlY3RydW1baV07XG4gICAgc3BlY3RydW1bc2l6ZSAtIGkgKyAxXSA9IC1zcGVjdHJ1bVtpICsgMV07XG4gIH1cbn07XG5cbkZGVC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKG91dCwgZGF0YSkge1xuICBpZiAob3V0ID09PSBkYXRhKVxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Jyk7XG5cbiAgdGhpcy5fb3V0ID0gb3V0O1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgdGhpcy5faW52ID0gMDtcbiAgdGhpcy5fdHJhbnNmb3JtNCgpO1xuICB0aGlzLl9vdXQgPSBudWxsO1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbn07XG5cbkZGVC5wcm90b3R5cGUucmVhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHJlYWxUcmFuc2Zvcm0ob3V0LCBkYXRhKSB7XG4gIGlmIChvdXQgPT09IGRhdGEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQnKTtcblxuICB0aGlzLl9vdXQgPSBvdXQ7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB0aGlzLl9pbnYgPSAwO1xuICB0aGlzLl9yZWFsVHJhbnNmb3JtNCgpO1xuICB0aGlzLl9vdXQgPSBudWxsO1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbn07XG5cbkZGVC5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0ob3V0LCBkYXRhKSB7XG4gIGlmIChvdXQgPT09IGRhdGEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgbXVzdCBiZSBkaWZmZXJlbnQnKTtcblxuICB0aGlzLl9vdXQgPSBvdXQ7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB0aGlzLl9pbnYgPSAxO1xuICB0aGlzLl90cmFuc2Zvcm00KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxuICAgIG91dFtpXSAvPSB0aGlzLnNpemU7XG4gIHRoaXMuX291dCA9IG51bGw7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xufTtcblxuLy8gcmFkaXgtNCBpbXBsZW1lbnRhdGlvblxuLy9cbi8vIE5PVEU6IFVzZXMgb2YgYHZhcmAgYXJlIGludGVudGlvbmFsIGZvciBvbGRlciBWOCB2ZXJzaW9uIHRoYXQgZG8gbm90XG4vLyBzdXBwb3J0IGJvdGggYGxldCBjb21wb3VuZCBhc3NpZ25tZW50c2AgYW5kIGBjb25zdCBwaGlgXG5GRlQucHJvdG90eXBlLl90cmFuc2Zvcm00ID0gZnVuY3Rpb24gX3RyYW5zZm9ybTQoKSB7XG4gIHZhciBvdXQgPSB0aGlzLl9vdXQ7XG4gIHZhciBzaXplID0gdGhpcy5fY3NpemU7XG5cbiAgLy8gSW5pdGlhbCBzdGVwIChwZXJtdXRlIGFuZCB0cmFuc2Zvcm0pXG4gIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICB2YXIgc3RlcCA9IDEgPDwgd2lkdGg7XG4gIHZhciBsZW4gPSAoc2l6ZSAvIHN0ZXApIDw8IDE7XG5cbiAgdmFyIG91dE9mZjtcbiAgdmFyIHQ7XG4gIHZhciBiaXRyZXYgPSB0aGlzLl9iaXRyZXY7XG4gIGlmIChsZW4gPT09IDQpIHtcbiAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCB0KyspIHtcbiAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgIHRoaXMuX3NpbmdsZVRyYW5zZm9ybTIob3V0T2ZmLCBvZmYsIHN0ZXApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBsZW4gPT09IDhcbiAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCB0KyspIHtcbiAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgIHRoaXMuX3NpbmdsZVRyYW5zZm9ybTQob3V0T2ZmLCBvZmYsIHN0ZXApO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvb3AgdGhyb3VnaCBzdGVwcyBpbiBkZWNyZWFzaW5nIG9yZGVyXG4gIHZhciBpbnYgPSB0aGlzLl9pbnYgPyAtMSA6IDE7XG4gIHZhciB0YWJsZSA9IHRoaXMudGFibGU7XG4gIGZvciAoc3RlcCA+Pj0gMjsgc3RlcCA+PSAyOyBzdGVwID4+PSAyKSB7XG4gICAgbGVuID0gKHNpemUgLyBzdGVwKSA8PCAxO1xuICAgIHZhciBxdWFydGVyTGVuID0gbGVuID4+PiAyO1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIG9mZnNldHMgaW4gdGhlIGRhdGFcbiAgICBmb3IgKG91dE9mZiA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4pIHtcbiAgICAgIC8vIEZ1bGwgY2FzZVxuICAgICAgdmFyIGxpbWl0ID0gb3V0T2ZmICsgcXVhcnRlckxlbjtcbiAgICAgIGZvciAodmFyIGkgPSBvdXRPZmYsIGsgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMiwgayArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IEEgPSBpO1xuICAgICAgICBjb25zdCBCID0gQSArIHF1YXJ0ZXJMZW47XG4gICAgICAgIGNvbnN0IEMgPSBCICsgcXVhcnRlckxlbjtcbiAgICAgICAgY29uc3QgRCA9IEMgKyBxdWFydGVyTGVuO1xuXG4gICAgICAgIC8vIE9yaWdpbmFsIHZhbHVlc1xuICAgICAgICBjb25zdCBBciA9IG91dFtBXTtcbiAgICAgICAgY29uc3QgQWkgPSBvdXRbQSArIDFdO1xuICAgICAgICBjb25zdCBCciA9IG91dFtCXTtcbiAgICAgICAgY29uc3QgQmkgPSBvdXRbQiArIDFdO1xuICAgICAgICBjb25zdCBDciA9IG91dFtDXTtcbiAgICAgICAgY29uc3QgQ2kgPSBvdXRbQyArIDFdO1xuICAgICAgICBjb25zdCBEciA9IG91dFtEXTtcbiAgICAgICAgY29uc3QgRGkgPSBvdXRbRCArIDFdO1xuXG4gICAgICAgIC8vIE1pZGRsZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgTUFyID0gQXI7XG4gICAgICAgIGNvbnN0IE1BaSA9IEFpO1xuXG4gICAgICAgIGNvbnN0IHRhYmxlQnIgPSB0YWJsZVtrXTtcbiAgICAgICAgY29uc3QgdGFibGVCaSA9IGludiAqIHRhYmxlW2sgKyAxXTtcbiAgICAgICAgY29uc3QgTUJyID0gQnIgKiB0YWJsZUJyIC0gQmkgKiB0YWJsZUJpO1xuICAgICAgICBjb25zdCBNQmkgPSBCciAqIHRhYmxlQmkgKyBCaSAqIHRhYmxlQnI7XG5cbiAgICAgICAgY29uc3QgdGFibGVDciA9IHRhYmxlWzIgKiBrXTtcbiAgICAgICAgY29uc3QgdGFibGVDaSA9IGludiAqIHRhYmxlWzIgKiBrICsgMV07XG4gICAgICAgIGNvbnN0IE1DciA9IENyICogdGFibGVDciAtIENpICogdGFibGVDaTtcbiAgICAgICAgY29uc3QgTUNpID0gQ3IgKiB0YWJsZUNpICsgQ2kgKiB0YWJsZUNyO1xuXG4gICAgICAgIGNvbnN0IHRhYmxlRHIgPSB0YWJsZVszICoga107XG4gICAgICAgIGNvbnN0IHRhYmxlRGkgPSBpbnYgKiB0YWJsZVszICogayArIDFdO1xuICAgICAgICBjb25zdCBNRHIgPSBEciAqIHRhYmxlRHIgLSBEaSAqIHRhYmxlRGk7XG4gICAgICAgIGNvbnN0IE1EaSA9IERyICogdGFibGVEaSArIERpICogdGFibGVEcjtcblxuICAgICAgICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IFQwciA9IE1BciArIE1DcjtcbiAgICAgICAgY29uc3QgVDBpID0gTUFpICsgTUNpO1xuICAgICAgICBjb25zdCBUMXIgPSBNQXIgLSBNQ3I7XG4gICAgICAgIGNvbnN0IFQxaSA9IE1BaSAtIE1DaTtcbiAgICAgICAgY29uc3QgVDJyID0gTUJyICsgTURyO1xuICAgICAgICBjb25zdCBUMmkgPSBNQmkgKyBNRGk7XG4gICAgICAgIGNvbnN0IFQzciA9IGludiAqIChNQnIgLSBNRHIpO1xuICAgICAgICBjb25zdCBUM2kgPSBpbnYgKiAoTUJpIC0gTURpKTtcblxuICAgICAgICAvLyBGaW5hbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgRkFyID0gVDByICsgVDJyO1xuICAgICAgICBjb25zdCBGQWkgPSBUMGkgKyBUMmk7XG5cbiAgICAgICAgY29uc3QgRkNyID0gVDByIC0gVDJyO1xuICAgICAgICBjb25zdCBGQ2kgPSBUMGkgLSBUMmk7XG5cbiAgICAgICAgY29uc3QgRkJyID0gVDFyICsgVDNpO1xuICAgICAgICBjb25zdCBGQmkgPSBUMWkgLSBUM3I7XG5cbiAgICAgICAgY29uc3QgRkRyID0gVDFyIC0gVDNpO1xuICAgICAgICBjb25zdCBGRGkgPSBUMWkgKyBUM3I7XG5cbiAgICAgICAgb3V0W0FdID0gRkFyO1xuICAgICAgICBvdXRbQSArIDFdID0gRkFpO1xuICAgICAgICBvdXRbQl0gPSBGQnI7XG4gICAgICAgIG91dFtCICsgMV0gPSBGQmk7XG4gICAgICAgIG91dFtDXSA9IEZDcjtcbiAgICAgICAgb3V0W0MgKyAxXSA9IEZDaTtcbiAgICAgICAgb3V0W0RdID0gRkRyO1xuICAgICAgICBvdXRbRCArIDFdID0gRkRpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gcmFkaXgtMiBpbXBsZW1lbnRhdGlvblxuLy9cbi8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49NFxuRkZULnByb3RvdHlwZS5fc2luZ2xlVHJhbnNmb3JtMiA9IGZ1bmN0aW9uIF9zaW5nbGVUcmFuc2Zvcm0yKG91dE9mZiwgb2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXApIHtcbiAgY29uc3Qgb3V0ID0gdGhpcy5fb3V0O1xuICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcblxuICBjb25zdCBldmVuUiA9IGRhdGFbb2ZmXTtcbiAgY29uc3QgZXZlbkkgPSBkYXRhW29mZiArIDFdO1xuICBjb25zdCBvZGRSID0gZGF0YVtvZmYgKyBzdGVwXTtcbiAgY29uc3Qgb2RkSSA9IGRhdGFbb2ZmICsgc3RlcCArIDFdO1xuXG4gIGNvbnN0IGxlZnRSID0gZXZlblIgKyBvZGRSO1xuICBjb25zdCBsZWZ0SSA9IGV2ZW5JICsgb2RkSTtcbiAgY29uc3QgcmlnaHRSID0gZXZlblIgLSBvZGRSO1xuICBjb25zdCByaWdodEkgPSBldmVuSSAtIG9kZEk7XG5cbiAgb3V0W291dE9mZl0gPSBsZWZ0UjtcbiAgb3V0W291dE9mZiArIDFdID0gbGVmdEk7XG4gIG91dFtvdXRPZmYgKyAyXSA9IHJpZ2h0UjtcbiAgb3V0W291dE9mZiArIDNdID0gcmlnaHRJO1xufTtcblxuLy8gcmFkaXgtNFxuLy9cbi8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49OFxuRkZULnByb3RvdHlwZS5fc2luZ2xlVHJhbnNmb3JtNCA9IGZ1bmN0aW9uIF9zaW5nbGVUcmFuc2Zvcm00KG91dE9mZiwgb2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXApIHtcbiAgY29uc3Qgb3V0ID0gdGhpcy5fb3V0O1xuICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgY29uc3QgaW52ID0gdGhpcy5faW52ID8gLTEgOiAxO1xuICBjb25zdCBzdGVwMiA9IHN0ZXAgKiAyO1xuICBjb25zdCBzdGVwMyA9IHN0ZXAgKiAzO1xuXG4gIC8vIE9yaWdpbmFsIHZhbHVlc1xuICBjb25zdCBBciA9IGRhdGFbb2ZmXTtcbiAgY29uc3QgQWkgPSBkYXRhW29mZiArIDFdO1xuICBjb25zdCBCciA9IGRhdGFbb2ZmICsgc3RlcF07XG4gIGNvbnN0IEJpID0gZGF0YVtvZmYgKyBzdGVwICsgMV07XG4gIGNvbnN0IENyID0gZGF0YVtvZmYgKyBzdGVwMl07XG4gIGNvbnN0IENpID0gZGF0YVtvZmYgKyBzdGVwMiArIDFdO1xuICBjb25zdCBEciA9IGRhdGFbb2ZmICsgc3RlcDNdO1xuICBjb25zdCBEaSA9IGRhdGFbb2ZmICsgc3RlcDMgKyAxXTtcblxuICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gIGNvbnN0IFQwciA9IEFyICsgQ3I7XG4gIGNvbnN0IFQwaSA9IEFpICsgQ2k7XG4gIGNvbnN0IFQxciA9IEFyIC0gQ3I7XG4gIGNvbnN0IFQxaSA9IEFpIC0gQ2k7XG4gIGNvbnN0IFQyciA9IEJyICsgRHI7XG4gIGNvbnN0IFQyaSA9IEJpICsgRGk7XG4gIGNvbnN0IFQzciA9IGludiAqIChCciAtIERyKTtcbiAgY29uc3QgVDNpID0gaW52ICogKEJpIC0gRGkpO1xuXG4gIC8vIEZpbmFsIHZhbHVlc1xuICBjb25zdCBGQXIgPSBUMHIgKyBUMnI7XG4gIGNvbnN0IEZBaSA9IFQwaSArIFQyaTtcblxuICBjb25zdCBGQnIgPSBUMXIgKyBUM2k7XG4gIGNvbnN0IEZCaSA9IFQxaSAtIFQzcjtcblxuICBjb25zdCBGQ3IgPSBUMHIgLSBUMnI7XG4gIGNvbnN0IEZDaSA9IFQwaSAtIFQyaTtcblxuICBjb25zdCBGRHIgPSBUMXIgLSBUM2k7XG4gIGNvbnN0IEZEaSA9IFQxaSArIFQzcjtcblxuICBvdXRbb3V0T2ZmXSA9IEZBcjtcbiAgb3V0W291dE9mZiArIDFdID0gRkFpO1xuICBvdXRbb3V0T2ZmICsgMl0gPSBGQnI7XG4gIG91dFtvdXRPZmYgKyAzXSA9IEZCaTtcbiAgb3V0W291dE9mZiArIDRdID0gRkNyO1xuICBvdXRbb3V0T2ZmICsgNV0gPSBGQ2k7XG4gIG91dFtvdXRPZmYgKyA2XSA9IEZEcjtcbiAgb3V0W291dE9mZiArIDddID0gRkRpO1xufTtcblxuLy8gUmVhbCBpbnB1dCByYWRpeC00IGltcGxlbWVudGF0aW9uXG5GRlQucHJvdG90eXBlLl9yZWFsVHJhbnNmb3JtNCA9IGZ1bmN0aW9uIF9yZWFsVHJhbnNmb3JtNCgpIHtcbiAgdmFyIG91dCA9IHRoaXMuX291dDtcbiAgdmFyIHNpemUgPSB0aGlzLl9jc2l6ZTtcblxuICAvLyBJbml0aWFsIHN0ZXAgKHBlcm11dGUgYW5kIHRyYW5zZm9ybSlcbiAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gIHZhciBzdGVwID0gMSA8PCB3aWR0aDtcbiAgdmFyIGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcblxuICB2YXIgb3V0T2ZmO1xuICB2YXIgdDtcbiAgdmFyIGJpdHJldiA9IHRoaXMuX2JpdHJldjtcbiAgaWYgKGxlbiA9PT0gNCkge1xuICAgIGZvciAob3V0T2ZmID0gMCwgdCA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4sIHQrKykge1xuICAgICAgY29uc3Qgb2ZmID0gYml0cmV2W3RdO1xuICAgICAgdGhpcy5fc2luZ2xlUmVhbFRyYW5zZm9ybTIob3V0T2ZmLCBvZmYgPj4+IDEsIHN0ZXAgPj4+IDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBsZW4gPT09IDhcbiAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCB0KyspIHtcbiAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgIHRoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm00KG91dE9mZiwgb2ZmID4+PiAxLCBzdGVwID4+PiAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29wIHRocm91Z2ggc3RlcHMgaW4gZGVjcmVhc2luZyBvcmRlclxuICB2YXIgaW52ID0gdGhpcy5faW52ID8gLTEgOiAxO1xuICB2YXIgdGFibGUgPSB0aGlzLnRhYmxlO1xuICBmb3IgKHN0ZXAgPj49IDI7IHN0ZXAgPj0gMjsgc3RlcCA+Pj0gMikge1xuICAgIGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcbiAgICB2YXIgaGFsZkxlbiA9IGxlbiA+Pj4gMTtcbiAgICB2YXIgcXVhcnRlckxlbiA9IGhhbGZMZW4gPj4+IDE7XG4gICAgdmFyIGhxdWFydGVyTGVuID0gcXVhcnRlckxlbiA+Pj4gMTtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBvZmZzZXRzIGluIHRoZSBkYXRhXG4gICAgZm9yIChvdXRPZmYgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPD0gaHF1YXJ0ZXJMZW47IGkgKz0gMiwgayArPSBzdGVwKSB7XG4gICAgICAgIHZhciBBID0gb3V0T2ZmICsgaTtcbiAgICAgICAgdmFyIEIgPSBBICsgcXVhcnRlckxlbjtcbiAgICAgICAgdmFyIEMgPSBCICsgcXVhcnRlckxlbjtcbiAgICAgICAgdmFyIEQgPSBDICsgcXVhcnRlckxlbjtcblxuICAgICAgICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgdmFyIEFyID0gb3V0W0FdO1xuICAgICAgICB2YXIgQWkgPSBvdXRbQSArIDFdO1xuICAgICAgICB2YXIgQnIgPSBvdXRbQl07XG4gICAgICAgIHZhciBCaSA9IG91dFtCICsgMV07XG4gICAgICAgIHZhciBDciA9IG91dFtDXTtcbiAgICAgICAgdmFyIENpID0gb3V0W0MgKyAxXTtcbiAgICAgICAgdmFyIERyID0gb3V0W0RdO1xuICAgICAgICB2YXIgRGkgPSBvdXRbRCArIDFdO1xuXG4gICAgICAgIC8vIE1pZGRsZSB2YWx1ZXNcbiAgICAgICAgdmFyIE1BciA9IEFyO1xuICAgICAgICB2YXIgTUFpID0gQWk7XG5cbiAgICAgICAgdmFyIHRhYmxlQnIgPSB0YWJsZVtrXTtcbiAgICAgICAgdmFyIHRhYmxlQmkgPSBpbnYgKiB0YWJsZVtrICsgMV07XG4gICAgICAgIHZhciBNQnIgPSBCciAqIHRhYmxlQnIgLSBCaSAqIHRhYmxlQmk7XG4gICAgICAgIHZhciBNQmkgPSBCciAqIHRhYmxlQmkgKyBCaSAqIHRhYmxlQnI7XG5cbiAgICAgICAgdmFyIHRhYmxlQ3IgPSB0YWJsZVsyICoga107XG4gICAgICAgIHZhciB0YWJsZUNpID0gaW52ICogdGFibGVbMiAqIGsgKyAxXTtcbiAgICAgICAgdmFyIE1DciA9IENyICogdGFibGVDciAtIENpICogdGFibGVDaTtcbiAgICAgICAgdmFyIE1DaSA9IENyICogdGFibGVDaSArIENpICogdGFibGVDcjtcblxuICAgICAgICB2YXIgdGFibGVEciA9IHRhYmxlWzMgKiBrXTtcbiAgICAgICAgdmFyIHRhYmxlRGkgPSBpbnYgKiB0YWJsZVszICogayArIDFdO1xuICAgICAgICB2YXIgTURyID0gRHIgKiB0YWJsZURyIC0gRGkgKiB0YWJsZURpO1xuICAgICAgICB2YXIgTURpID0gRHIgKiB0YWJsZURpICsgRGkgKiB0YWJsZURyO1xuXG4gICAgICAgIC8vIFByZS1GaW5hbCB2YWx1ZXNcbiAgICAgICAgdmFyIFQwciA9IE1BciArIE1DcjtcbiAgICAgICAgdmFyIFQwaSA9IE1BaSArIE1DaTtcbiAgICAgICAgdmFyIFQxciA9IE1BciAtIE1DcjtcbiAgICAgICAgdmFyIFQxaSA9IE1BaSAtIE1DaTtcbiAgICAgICAgdmFyIFQyciA9IE1CciArIE1EcjtcbiAgICAgICAgdmFyIFQyaSA9IE1CaSArIE1EaTtcbiAgICAgICAgdmFyIFQzciA9IGludiAqIChNQnIgLSBNRHIpO1xuICAgICAgICB2YXIgVDNpID0gaW52ICogKE1CaSAtIE1EaSk7XG5cbiAgICAgICAgLy8gRmluYWwgdmFsdWVzXG4gICAgICAgIHZhciBGQXIgPSBUMHIgKyBUMnI7XG4gICAgICAgIHZhciBGQWkgPSBUMGkgKyBUMmk7XG5cbiAgICAgICAgdmFyIEZCciA9IFQxciArIFQzaTtcbiAgICAgICAgdmFyIEZCaSA9IFQxaSAtIFQzcjtcblxuICAgICAgICBvdXRbQV0gPSBGQXI7XG4gICAgICAgIG91dFtBICsgMV0gPSBGQWk7XG4gICAgICAgIG91dFtCXSA9IEZCcjtcbiAgICAgICAgb3V0W0IgKyAxXSA9IEZCaTtcblxuICAgICAgICAvLyBPdXRwdXQgZmluYWwgbWlkZGxlIHBvaW50XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgdmFyIEZDciA9IFQwciAtIFQycjtcbiAgICAgICAgICB2YXIgRkNpID0gVDBpIC0gVDJpO1xuICAgICAgICAgIG91dFtDXSA9IEZDcjtcbiAgICAgICAgICBvdXRbQyArIDFdID0gRkNpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSBvdXJzZWx2ZXNcbiAgICAgICAgaWYgKGkgPT09IGhxdWFydGVyTGVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEluIHRoZSBmbGlwcGVkIGNhc2U6XG4gICAgICAgIC8vIE1BaSA9IC1NQWlcbiAgICAgICAgLy8gTUJyPS1NQmksIE1CaT0tTUJyXG4gICAgICAgIC8vIE1Dcj0tTUNyXG4gICAgICAgIC8vIE1Ecj1NRGksIE1EaT1NRHJcbiAgICAgICAgdmFyIFNUMHIgPSBUMXI7XG4gICAgICAgIHZhciBTVDBpID0gLVQxaTtcbiAgICAgICAgdmFyIFNUMXIgPSBUMHI7XG4gICAgICAgIHZhciBTVDFpID0gLVQwaTtcbiAgICAgICAgdmFyIFNUMnIgPSAtaW52ICogVDNpO1xuICAgICAgICB2YXIgU1QyaSA9IC1pbnYgKiBUM3I7XG4gICAgICAgIHZhciBTVDNyID0gLWludiAqIFQyaTtcbiAgICAgICAgdmFyIFNUM2kgPSAtaW52ICogVDJyO1xuXG4gICAgICAgIHZhciBTRkFyID0gU1QwciArIFNUMnI7XG4gICAgICAgIHZhciBTRkFpID0gU1QwaSArIFNUMmk7XG5cbiAgICAgICAgdmFyIFNGQnIgPSBTVDFyICsgU1QzaTtcbiAgICAgICAgdmFyIFNGQmkgPSBTVDFpIC0gU1QzcjtcblxuICAgICAgICB2YXIgU0EgPSBvdXRPZmYgKyBxdWFydGVyTGVuIC0gaTtcbiAgICAgICAgdmFyIFNCID0gb3V0T2ZmICsgaGFsZkxlbiAtIGk7XG5cbiAgICAgICAgb3V0W1NBXSA9IFNGQXI7XG4gICAgICAgIG91dFtTQSArIDFdID0gU0ZBaTtcbiAgICAgICAgb3V0W1NCXSA9IFNGQnI7XG4gICAgICAgIG91dFtTQiArIDFdID0gU0ZCaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHJhZGl4LTIgaW1wbGVtZW50YXRpb25cbi8vXG4vLyBOT1RFOiBPbmx5IGNhbGxlZCBmb3IgbGVuPTRcbkZGVC5wcm90b3R5cGUuX3NpbmdsZVJlYWxUcmFuc2Zvcm0yID0gZnVuY3Rpb24gX3NpbmdsZVJlYWxUcmFuc2Zvcm0yKG91dE9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXApIHtcbiAgY29uc3Qgb3V0ID0gdGhpcy5fb3V0O1xuICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcblxuICBjb25zdCBldmVuUiA9IGRhdGFbb2ZmXTtcbiAgY29uc3Qgb2RkUiA9IGRhdGFbb2ZmICsgc3RlcF07XG5cbiAgY29uc3QgbGVmdFIgPSBldmVuUiArIG9kZFI7XG4gIGNvbnN0IHJpZ2h0UiA9IGV2ZW5SIC0gb2RkUjtcblxuICBvdXRbb3V0T2ZmXSA9IGxlZnRSO1xuICBvdXRbb3V0T2ZmICsgMV0gPSAwO1xuICBvdXRbb3V0T2ZmICsgMl0gPSByaWdodFI7XG4gIG91dFtvdXRPZmYgKyAzXSA9IDA7XG59O1xuXG4vLyByYWRpeC00XG4vL1xuLy8gTk9URTogT25seSBjYWxsZWQgZm9yIGxlbj04XG5GRlQucHJvdG90eXBlLl9zaW5nbGVSZWFsVHJhbnNmb3JtNCA9IGZ1bmN0aW9uIF9zaW5nbGVSZWFsVHJhbnNmb3JtNChvdXRPZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwKSB7XG4gIGNvbnN0IG91dCA9IHRoaXMuX291dDtcbiAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gIGNvbnN0IGludiA9IHRoaXMuX2ludiA/IC0xIDogMTtcbiAgY29uc3Qgc3RlcDIgPSBzdGVwICogMjtcbiAgY29uc3Qgc3RlcDMgPSBzdGVwICogMztcblxuICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgY29uc3QgQXIgPSBkYXRhW29mZl07XG4gIGNvbnN0IEJyID0gZGF0YVtvZmYgKyBzdGVwXTtcbiAgY29uc3QgQ3IgPSBkYXRhW29mZiArIHN0ZXAyXTtcbiAgY29uc3QgRHIgPSBkYXRhW29mZiArIHN0ZXAzXTtcblxuICAvLyBQcmUtRmluYWwgdmFsdWVzXG4gIGNvbnN0IFQwciA9IEFyICsgQ3I7XG4gIGNvbnN0IFQxciA9IEFyIC0gQ3I7XG4gIGNvbnN0IFQyciA9IEJyICsgRHI7XG4gIGNvbnN0IFQzciA9IGludiAqIChCciAtIERyKTtcblxuICAvLyBGaW5hbCB2YWx1ZXNcbiAgY29uc3QgRkFyID0gVDByICsgVDJyO1xuXG4gIGNvbnN0IEZCciA9IFQxcjtcbiAgY29uc3QgRkJpID0gLVQzcjtcblxuICBjb25zdCBGQ3IgPSBUMHIgLSBUMnI7XG5cbiAgY29uc3QgRkRyID0gVDFyO1xuICBjb25zdCBGRGkgPSBUM3I7XG5cbiAgb3V0W291dE9mZl0gPSBGQXI7XG4gIG91dFtvdXRPZmYgKyAxXSA9IDA7XG4gIG91dFtvdXRPZmYgKyAyXSA9IEZCcjtcbiAgb3V0W291dE9mZiArIDNdID0gRkJpO1xuICBvdXRbb3V0T2ZmICsgNF0gPSBGQ3I7XG4gIG91dFtvdXRPZmYgKyA1XSA9IDA7XG4gIG91dFtvdXRPZmYgKyA2XSA9IEZEcjtcbiAgb3V0W291dE9mZiArIDddID0gRkRpO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fft.js/lib/fft.js\n");

/***/ })

};
;