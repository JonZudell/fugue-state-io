/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/workers/summarize.worker.js":
/*!*****************************************!*\
  !*** ./src/workers/summarize.worker.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const SAMPLE_BIN_SIZE = 4096;\nconst HALF_SAMPLE_BIN_SIZE = Math.floor(SAMPLE_BIN_SIZE / 2);\nconst WINDOW_FUNCTION = \"hamming\";\n\nfunction applyWindowFunction(data, windowType) {\n  const N = data.length;\n  switch (windowType) {\n    case \"hamming\":\n      return data.map(\n        (value, n) =>\n          value * (0.54 - 0.46 * Math.cos((2 * Math.PI * n) / (N - 1))),\n      );\n    case \"hann\":\n      return data.map(\n        (value, n) =>\n          value * (0.5 * (1 - Math.cos((2 * Math.PI * n) / (N - 1)))),\n      );\n    case \"blackman\":\n      return data.map(\n        (value, n) =>\n          value *\n          (0.42 -\n            0.5 * Math.cos((2 * Math.PI * n) / (N - 1)) +\n            0.08 * Math.cos((4 * Math.PI * n) / (N - 1))),\n      );\n    case \"rectangular\":\n      return data; // No windowing\n    case \"bartlett\":\n      return data.map(\n        (value, n) =>\n          value * (2 / (N - 1)) * ((N - 1) / 2 - Math.abs(n - (N - 1) / 2)),\n      );\n    default:\n      throw new Error(\"Unknown window type\");\n  }\n}\n\nfunction radix_4_fft(input) {\n  try {\n    const N = input.length;\n    if (N <= 1) return input;\n\n    // Handle radix-2 case\n    if (N === 2) {\n      return [input[0] + input[1], input[0] - input[1]];\n    }\n\n    // Ensure the input length is a power of 4\n    if ((N & (N - 1)) !== 0 || (N & 0x55555555) !== N) {\n      throw new Error(\"Input length must be a power of 4\");\n    }\n\n    // Split the input into four smaller arrays\n    const even = [],\n      odd = [],\n      even2 = [],\n      odd2 = [];\n    for (let i = 0; i < N / 4; i++) {\n      even.push(input[4 * i]);\n      odd.push(input[4 * i + 1]);\n      even2.push(input[4 * i + 2]);\n      odd2.push(input[4 * i + 3]);\n    }\n\n    // Recursively apply the radix-4 FFT to the smaller arrays\n    const evenFFT = radix_4_fft(even);\n    const oddFFT = radix_4_fft(odd);\n    const even2FFT = radix_4_fft(even2);\n    const odd2FFT = radix_4_fft(odd2);\n\n    // Combine the results using the butterfly operations\n    const result = new Array(N);\n    for (let k = 0; k < N / 4; k++) {\n      const t0 = evenFFT[k];\n      const t1 = oddFFT[k];\n      const t2 = even2FFT[k];\n      const t3 = odd2FFT[k];\n\n      const twiddle1 = Math.exp((-2 * Math.PI * k) / N);\n      const twiddle2 = Math.exp((-4 * Math.PI * k) / N);\n      const twiddle3 = Math.exp((-6 * Math.PI * k) / N);\n\n      result[k] = t0 + twiddle1 * t1 + twiddle2 * t2 + twiddle3 * t3;\n      result[k + N / 4] = t0 - twiddle1 * t1 + twiddle2 * t2 - twiddle3 * t3;\n      result[k + N / 2] = t0 + twiddle1 * t1 - twiddle2 * t2 - twiddle3 * t3;\n      result[k + (3 * N) / 4] =\n        t0 - twiddle1 * t1 - twiddle2 * t2 + twiddle3 * t3;\n    }\n\n    return result;\n  } catch (error) {\n    throw error;\n  }\n}\nfunction frameFromSlice(array, start, end) {\n  const data = array.slice(start, end);\n  return {\n    data: data,\n    start: start,\n    end: end,\n  };\n}\nfunction interleavedFramesFromChannelData(data) {\n  try {\n    data = new Float32Array(data);\n    const frames = [];\n    const interpolatedFrameCount = data.length / HALF_SAMPLE_BIN_SIZE;\n    console.log(\"Interpolated frame count:\", interpolatedFrameCount);\n    for (let i = 0; i < interpolatedFrameCount; i++) {\n      const start = i * HALF_SAMPLE_BIN_SIZE;\n      const end = Math.min(\n        i * HALF_SAMPLE_BIN_SIZE + SAMPLE_BIN_SIZE,\n        data.length,\n      );\n      const frame = frameFromSlice(data, start, end);\n      frames.push(frame);\n    }\n\n    return frames;\n  } catch (error) {\n    console.error(\"Error in interleavedFramesFromChannelData:\", error);\n    throw error;\n  }\n}\n\nfunction summarizeFrame(frame) {\n  try {\n    const count = frame.data.length;\n    const max = Math.max(...frame.data);\n    const min = Math.min(...frame.data);\n    const avg = frame.data.reduce((a, b) => a + b, 0) / count;\n    const input = new Array(SAMPLE_BIN_SIZE).fill(0);\n    // Apply windowing function before transforming\n    const windowedData = applyWindowFunction(frame.data, WINDOW_FUNCTION);\n\n    windowedData.forEach((value, index) => {\n      input[index] = value;\n    });\n    const output = radix_4_fft(input);\n    const magnitudes = [];\n    for (let i = 0; i < output.length; i += 2) {\n      magnitudes.push(Math.sqrt(output[i] ** 2 + output[i + 1] ** 2));\n    }\n\n    return {\n      max: max,\n      min: min,\n      avg: avg,\n      fft: output,\n      magnitudes: magnitudes,\n    };\n  } catch (error) {\n    console.error(\"Error in summarizeFrame:\", error);\n    throw error;\n  }\n}\n\nfunction summarizeInterleavedFrames(frames, channel, id, postMessage) {\n  try {\n    console.log(\"Summarizing frames\", frames);\n    let lastFrame = summarizeFrame(frames[0]);\n    postMessage({\n      type: \"CHANNEL_PROGRESS\",\n      id: id,\n      channel: channel,\n      progress: 0,\n    });\n\n    const summarizedFrames = [];\n\n    let ndx = 0;\n\n    while (ndx < frames.length) {\n      const summarizedFrame = summarizeFrame(frames[ndx]);\n      const thisFrame = { ...summarizedFrames[ndx] };\n\n      thisFrame.max = (lastFrame.max + summarizedFrame.max) / 2;\n      thisFrame.min = (lastFrame.min + summarizedFrame.min) / 2;\n      thisFrame.avg = (lastFrame.avg + summarizedFrame.avg) / 2;\n      thisFrame.fft = lastFrame.fft.map(\n        (value, index) => (value + summarizedFrame.fft[index]) / 2,\n      );\n      thisFrame.magnitudes = lastFrame.magnitudes.map(\n        (value, index) => (value + summarizedFrame.magnitudes[index]) / 2,\n      );\n\n      summarizedFrames.push(thisFrame);\n      lastFrame = summarizedFrame;\n      if (ndx % 100 === 0) {\n        postMessage({\n          type: \"CHANNEL_PROGRESS\",\n          channel: channel,\n          progress: ndx / frames.length,\n          id: id,\n        });\n      }\n      ndx++;\n    }\n    return summarizedFrames;\n  } catch (error) {\n    console.error(\"Error in summarizeInterleavedFrames:\", error);\n    throw error;\n  }\n}\n\nfunction process(arrayBuffer, channel, id, postMessage) {\n  try {\n    console.log(\"Processing arrayBuffer:\", arrayBuffer, channel);\n    const frames = interleavedFramesFromChannelData(arrayBuffer);\n    console.log(\"Interleaved frames:\", frames, channel);\n    const summarizedFrames = summarizeInterleavedFrames(\n      frames,\n      channel,\n      id,\n      postMessage,\n    );\n    postMessage({\n      type: \"CHANNEL_PROGRESS\",\n      channel: channel,\n      id: id,\n      progress: 1,\n    });\n    postMessage({\n      type: \"SUMMARIZED\",\n      summary: summarizedFrames,\n      id: id,\n      channel: channel,\n    });\n  } catch (error) {\n    console.error(\n      \"Error in process_file (audioContext.decodeAudioData):\",\n      error,\n    );\n    postMessage({ type: \"error\", error });\n  }\n}\nfunction checkReady(postMessage) {\n  try {\n    postMessage({ type: \"READY\" });\n  } catch (error) {\n    console.error(\"Error in checkReady:\", error);\n    postMessage({ type: \"error\", error });\n  }\n}\n\nself.addEventListener(\"message\", (event) => {\n  try {\n    console.log(\"Worker received message:\", event.data);\n    if (event.data && event.data.type === \"SUMMARIZE\") {\n      process(\n        event.data.arrayBuffer,\n        event.data.channel,\n        event.data.mediaId,\n        self.postMessage,\n      );\n    } else if (event.data && event.data.type === \"CHECK_READY\") {\n      checkReady(self.postMessage);\n    }\n  } catch (error) {\n    console.error(\"Error in message event listener:\", error);\n    self.postMessage({ type: \"error\", error });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvd29ya2Vycy9zdW1tYXJpemUud29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxJQUFJO0FBQ0o7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRob256dWRlbGwvV29ya3NwYWNlL2Z1Z3VlLXN0YXRlLWlvL3NyYy93b3JrZXJzL3N1bW1hcml6ZS53b3JrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU0FNUExFX0JJTl9TSVpFID0gNDA5NjtcbmNvbnN0IEhBTEZfU0FNUExFX0JJTl9TSVpFID0gTWF0aC5mbG9vcihTQU1QTEVfQklOX1NJWkUgLyAyKTtcbmNvbnN0IFdJTkRPV19GVU5DVElPTiA9IFwiaGFtbWluZ1wiO1xuXG5mdW5jdGlvbiBhcHBseVdpbmRvd0Z1bmN0aW9uKGRhdGEsIHdpbmRvd1R5cGUpIHtcbiAgY29uc3QgTiA9IGRhdGEubGVuZ3RoO1xuICBzd2l0Y2ggKHdpbmRvd1R5cGUpIHtcbiAgICBjYXNlIFwiaGFtbWluZ1wiOlxuICAgICAgcmV0dXJuIGRhdGEubWFwKFxuICAgICAgICAodmFsdWUsIG4pID0+XG4gICAgICAgICAgdmFsdWUgKiAoMC41NCAtIDAuNDYgKiBNYXRoLmNvcygoMiAqIE1hdGguUEkgKiBuKSAvIChOIC0gMSkpKSxcbiAgICAgICk7XG4gICAgY2FzZSBcImhhbm5cIjpcbiAgICAgIHJldHVybiBkYXRhLm1hcChcbiAgICAgICAgKHZhbHVlLCBuKSA9PlxuICAgICAgICAgIHZhbHVlICogKDAuNSAqICgxIC0gTWF0aC5jb3MoKDIgKiBNYXRoLlBJICogbikgLyAoTiAtIDEpKSkpLFxuICAgICAgKTtcbiAgICBjYXNlIFwiYmxhY2ttYW5cIjpcbiAgICAgIHJldHVybiBkYXRhLm1hcChcbiAgICAgICAgKHZhbHVlLCBuKSA9PlxuICAgICAgICAgIHZhbHVlICpcbiAgICAgICAgICAoMC40MiAtXG4gICAgICAgICAgICAwLjUgKiBNYXRoLmNvcygoMiAqIE1hdGguUEkgKiBuKSAvIChOIC0gMSkpICtcbiAgICAgICAgICAgIDAuMDggKiBNYXRoLmNvcygoNCAqIE1hdGguUEkgKiBuKSAvIChOIC0gMSkpKSxcbiAgICAgICk7XG4gICAgY2FzZSBcInJlY3Rhbmd1bGFyXCI6XG4gICAgICByZXR1cm4gZGF0YTsgLy8gTm8gd2luZG93aW5nXG4gICAgY2FzZSBcImJhcnRsZXR0XCI6XG4gICAgICByZXR1cm4gZGF0YS5tYXAoXG4gICAgICAgICh2YWx1ZSwgbikgPT5cbiAgICAgICAgICB2YWx1ZSAqICgyIC8gKE4gLSAxKSkgKiAoKE4gLSAxKSAvIDIgLSBNYXRoLmFicyhuIC0gKE4gLSAxKSAvIDIpKSxcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gd2luZG93IHR5cGVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFkaXhfNF9mZnQoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBOID0gaW5wdXQubGVuZ3RoO1xuICAgIGlmIChOIDw9IDEpIHJldHVybiBpbnB1dDtcblxuICAgIC8vIEhhbmRsZSByYWRpeC0yIGNhc2VcbiAgICBpZiAoTiA9PT0gMikge1xuICAgICAgcmV0dXJuIFtpbnB1dFswXSArIGlucHV0WzFdLCBpbnB1dFswXSAtIGlucHV0WzFdXTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGlucHV0IGxlbmd0aCBpcyBhIHBvd2VyIG9mIDRcbiAgICBpZiAoKE4gJiAoTiAtIDEpKSAhPT0gMCB8fCAoTiAmIDB4NTU1NTU1NTUpICE9PSBOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBsZW5ndGggbXVzdCBiZSBhIHBvd2VyIG9mIDRcIik7XG4gICAgfVxuXG4gICAgLy8gU3BsaXQgdGhlIGlucHV0IGludG8gZm91ciBzbWFsbGVyIGFycmF5c1xuICAgIGNvbnN0IGV2ZW4gPSBbXSxcbiAgICAgIG9kZCA9IFtdLFxuICAgICAgZXZlbjIgPSBbXSxcbiAgICAgIG9kZDIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE4gLyA0OyBpKyspIHtcbiAgICAgIGV2ZW4ucHVzaChpbnB1dFs0ICogaV0pO1xuICAgICAgb2RkLnB1c2goaW5wdXRbNCAqIGkgKyAxXSk7XG4gICAgICBldmVuMi5wdXNoKGlucHV0WzQgKiBpICsgMl0pO1xuICAgICAgb2RkMi5wdXNoKGlucHV0WzQgKiBpICsgM10pO1xuICAgIH1cblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGFwcGx5IHRoZSByYWRpeC00IEZGVCB0byB0aGUgc21hbGxlciBhcnJheXNcbiAgICBjb25zdCBldmVuRkZUID0gcmFkaXhfNF9mZnQoZXZlbik7XG4gICAgY29uc3Qgb2RkRkZUID0gcmFkaXhfNF9mZnQob2RkKTtcbiAgICBjb25zdCBldmVuMkZGVCA9IHJhZGl4XzRfZmZ0KGV2ZW4yKTtcbiAgICBjb25zdCBvZGQyRkZUID0gcmFkaXhfNF9mZnQob2RkMik7XG5cbiAgICAvLyBDb21iaW5lIHRoZSByZXN1bHRzIHVzaW5nIHRoZSBidXR0ZXJmbHkgb3BlcmF0aW9uc1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IE4gLyA0OyBrKyspIHtcbiAgICAgIGNvbnN0IHQwID0gZXZlbkZGVFtrXTtcbiAgICAgIGNvbnN0IHQxID0gb2RkRkZUW2tdO1xuICAgICAgY29uc3QgdDIgPSBldmVuMkZGVFtrXTtcbiAgICAgIGNvbnN0IHQzID0gb2RkMkZGVFtrXTtcblxuICAgICAgY29uc3QgdHdpZGRsZTEgPSBNYXRoLmV4cCgoLTIgKiBNYXRoLlBJICogaykgLyBOKTtcbiAgICAgIGNvbnN0IHR3aWRkbGUyID0gTWF0aC5leHAoKC00ICogTWF0aC5QSSAqIGspIC8gTik7XG4gICAgICBjb25zdCB0d2lkZGxlMyA9IE1hdGguZXhwKCgtNiAqIE1hdGguUEkgKiBrKSAvIE4pO1xuXG4gICAgICByZXN1bHRba10gPSB0MCArIHR3aWRkbGUxICogdDEgKyB0d2lkZGxlMiAqIHQyICsgdHdpZGRsZTMgKiB0MztcbiAgICAgIHJlc3VsdFtrICsgTiAvIDRdID0gdDAgLSB0d2lkZGxlMSAqIHQxICsgdHdpZGRsZTIgKiB0MiAtIHR3aWRkbGUzICogdDM7XG4gICAgICByZXN1bHRbayArIE4gLyAyXSA9IHQwICsgdHdpZGRsZTEgKiB0MSAtIHR3aWRkbGUyICogdDIgLSB0d2lkZGxlMyAqIHQzO1xuICAgICAgcmVzdWx0W2sgKyAoMyAqIE4pIC8gNF0gPVxuICAgICAgICB0MCAtIHR3aWRkbGUxICogdDEgLSB0d2lkZGxlMiAqIHQyICsgdHdpZGRsZTMgKiB0MztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBmcmFtZUZyb21TbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBkYXRhID0gYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmQsXG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcmxlYXZlZEZyYW1lc0Zyb21DaGFubmVsRGF0YShkYXRhKSB7XG4gIHRyeSB7XG4gICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgY29uc3QgZnJhbWVzID0gW107XG4gICAgY29uc3QgaW50ZXJwb2xhdGVkRnJhbWVDb3VudCA9IGRhdGEubGVuZ3RoIC8gSEFMRl9TQU1QTEVfQklOX1NJWkU7XG4gICAgY29uc29sZS5sb2coXCJJbnRlcnBvbGF0ZWQgZnJhbWUgY291bnQ6XCIsIGludGVycG9sYXRlZEZyYW1lQ291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJwb2xhdGVkRnJhbWVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGkgKiBIQUxGX1NBTVBMRV9CSU5fU0laRTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKFxuICAgICAgICBpICogSEFMRl9TQU1QTEVfQklOX1NJWkUgKyBTQU1QTEVfQklOX1NJWkUsXG4gICAgICAgIGRhdGEubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVGcm9tU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYW1lcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaW50ZXJsZWF2ZWRGcmFtZXNGcm9tQ2hhbm5lbERhdGE6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdW1tYXJpemVGcmFtZShmcmFtZSkge1xuICB0cnkge1xuICAgIGNvbnN0IGNvdW50ID0gZnJhbWUuZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4uZnJhbWUuZGF0YSk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oLi4uZnJhbWUuZGF0YSk7XG4gICAgY29uc3QgYXZnID0gZnJhbWUuZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGNvdW50O1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IEFycmF5KFNBTVBMRV9CSU5fU0laRSkuZmlsbCgwKTtcbiAgICAvLyBBcHBseSB3aW5kb3dpbmcgZnVuY3Rpb24gYmVmb3JlIHRyYW5zZm9ybWluZ1xuICAgIGNvbnN0IHdpbmRvd2VkRGF0YSA9IGFwcGx5V2luZG93RnVuY3Rpb24oZnJhbWUuZGF0YSwgV0lORE9XX0ZVTkNUSU9OKTtcblxuICAgIHdpbmRvd2VkRGF0YS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlucHV0W2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGNvbnN0IG91dHB1dCA9IHJhZGl4XzRfZmZ0KGlucHV0KTtcbiAgICBjb25zdCBtYWduaXR1ZGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG1hZ25pdHVkZXMucHVzaChNYXRoLnNxcnQob3V0cHV0W2ldICoqIDIgKyBvdXRwdXRbaSArIDFdICoqIDIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW46IG1pbixcbiAgICAgIGF2ZzogYXZnLFxuICAgICAgZmZ0OiBvdXRwdXQsXG4gICAgICBtYWduaXR1ZGVzOiBtYWduaXR1ZGVzLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHN1bW1hcml6ZUZyYW1lOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VtbWFyaXplSW50ZXJsZWF2ZWRGcmFtZXMoZnJhbWVzLCBjaGFubmVsLCBpZCwgcG9zdE1lc3NhZ2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlN1bW1hcml6aW5nIGZyYW1lc1wiLCBmcmFtZXMpO1xuICAgIGxldCBsYXN0RnJhbWUgPSBzdW1tYXJpemVGcmFtZShmcmFtZXNbMF0pO1xuICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwiQ0hBTk5FTF9QUk9HUkVTU1wiLFxuICAgICAgaWQ6IGlkLFxuICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3VtbWFyaXplZEZyYW1lcyA9IFtdO1xuXG4gICAgbGV0IG5keCA9IDA7XG5cbiAgICB3aGlsZSAobmR4IDwgZnJhbWVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3VtbWFyaXplZEZyYW1lID0gc3VtbWFyaXplRnJhbWUoZnJhbWVzW25keF0pO1xuICAgICAgY29uc3QgdGhpc0ZyYW1lID0geyAuLi5zdW1tYXJpemVkRnJhbWVzW25keF0gfTtcblxuICAgICAgdGhpc0ZyYW1lLm1heCA9IChsYXN0RnJhbWUubWF4ICsgc3VtbWFyaXplZEZyYW1lLm1heCkgLyAyO1xuICAgICAgdGhpc0ZyYW1lLm1pbiA9IChsYXN0RnJhbWUubWluICsgc3VtbWFyaXplZEZyYW1lLm1pbikgLyAyO1xuICAgICAgdGhpc0ZyYW1lLmF2ZyA9IChsYXN0RnJhbWUuYXZnICsgc3VtbWFyaXplZEZyYW1lLmF2ZykgLyAyO1xuICAgICAgdGhpc0ZyYW1lLmZmdCA9IGxhc3RGcmFtZS5mZnQubWFwKFxuICAgICAgICAodmFsdWUsIGluZGV4KSA9PiAodmFsdWUgKyBzdW1tYXJpemVkRnJhbWUuZmZ0W2luZGV4XSkgLyAyLFxuICAgICAgKTtcbiAgICAgIHRoaXNGcmFtZS5tYWduaXR1ZGVzID0gbGFzdEZyYW1lLm1hZ25pdHVkZXMubWFwKFxuICAgICAgICAodmFsdWUsIGluZGV4KSA9PiAodmFsdWUgKyBzdW1tYXJpemVkRnJhbWUubWFnbml0dWRlc1tpbmRleF0pIC8gMixcbiAgICAgICk7XG5cbiAgICAgIHN1bW1hcml6ZWRGcmFtZXMucHVzaCh0aGlzRnJhbWUpO1xuICAgICAgbGFzdEZyYW1lID0gc3VtbWFyaXplZEZyYW1lO1xuICAgICAgaWYgKG5keCAlIDEwMCA9PT0gMCkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogXCJDSEFOTkVMX1BST0dSRVNTXCIsXG4gICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgICBwcm9ncmVzczogbmR4IC8gZnJhbWVzLmxlbmd0aCxcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmR4Kys7XG4gICAgfVxuICAgIHJldHVybiBzdW1tYXJpemVkRnJhbWVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBzdW1tYXJpemVJbnRlcmxlYXZlZEZyYW1lczpcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3MoYXJyYXlCdWZmZXIsIGNoYW5uZWwsIGlkLCBwb3N0TWVzc2FnZSkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBhcnJheUJ1ZmZlcjpcIiwgYXJyYXlCdWZmZXIsIGNoYW5uZWwpO1xuICAgIGNvbnN0IGZyYW1lcyA9IGludGVybGVhdmVkRnJhbWVzRnJvbUNoYW5uZWxEYXRhKGFycmF5QnVmZmVyKTtcbiAgICBjb25zb2xlLmxvZyhcIkludGVybGVhdmVkIGZyYW1lczpcIiwgZnJhbWVzLCBjaGFubmVsKTtcbiAgICBjb25zdCBzdW1tYXJpemVkRnJhbWVzID0gc3VtbWFyaXplSW50ZXJsZWF2ZWRGcmFtZXMoXG4gICAgICBmcmFtZXMsXG4gICAgICBjaGFubmVsLFxuICAgICAgaWQsXG4gICAgICBwb3N0TWVzc2FnZSxcbiAgICApO1xuICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwiQ0hBTk5FTF9QUk9HUkVTU1wiLFxuICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHByb2dyZXNzOiAxLFxuICAgIH0pO1xuICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwiU1VNTUFSSVpFRFwiLFxuICAgICAgc3VtbWFyeTogc3VtbWFyaXplZEZyYW1lcyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiRXJyb3IgaW4gcHJvY2Vzc19maWxlIChhdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKTpcIixcbiAgICAgIGVycm9yLFxuICAgICk7XG4gICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlYWR5KHBvc3RNZXNzYWdlKSB7XG4gIHRyeSB7XG4gICAgcG9zdE1lc3NhZ2UoeyB0eXBlOiBcIlJFQURZXCIgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNoZWNrUmVhZHk6XCIsIGVycm9yKTtcbiAgICBwb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gIH1cbn1cblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIldvcmtlciByZWNlaXZlZCBtZXNzYWdlOlwiLCBldmVudC5kYXRhKTtcbiAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09IFwiU1VNTUFSSVpFXCIpIHtcbiAgICAgIHByb2Nlc3MoXG4gICAgICAgIGV2ZW50LmRhdGEuYXJyYXlCdWZmZXIsXG4gICAgICAgIGV2ZW50LmRhdGEuY2hhbm5lbCxcbiAgICAgICAgZXZlbnQuZGF0YS5tZWRpYUlkLFxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlID09PSBcIkNIRUNLX1JFQURZXCIpIHtcbiAgICAgIGNoZWNrUmVhZHkoc2VsZi5wb3N0TWVzc2FnZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBtZXNzYWdlIGV2ZW50IGxpc3RlbmVyOlwiLCBlcnJvcik7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/workers/summarize.worker.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/workers/summarize.worker.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;